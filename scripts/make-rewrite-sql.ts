import fs from "node:fs";
import path from "node:path";

type MapRec = Record<string, string>;

function parseArgs(argv: string[]) {
    const out: Record<string, string> = {};
    for (const a of argv) {
        const m = a.match(/^--([^=]+)=(.*)$/);
        if (m) out[m[1]] = m[2];
    }
    return out;
}

function extractMappings(json: any): MapRec {
    const m: MapRec = {};

    const put = (from: any, to: any) => {
        if (typeof from !== "string" || typeof to !== "string") return;
        if (!from || !to) return;
        m[from] = to;
        // 先頭スラッシュ無し版も追加（image_path が "cards/..." の場合に効く）
        if (from.startsWith("/") && to.startsWith("/")) {
            m[from.slice(1)] = to.slice(1);
        }
    };

    if (Array.isArray(json)) {
        for (const it of json) {
            if (it && typeof it === "object") {
                put(it.from ?? it.old ?? it.src, it.to ?? it.new ?? it.dst);
            }
        }
        return m;
    }

    if (json && typeof json === "object") {
        const container =
            json.mappings ?? json.map ?? json.mapping ?? json.items ?? json.data;
        if (container) {
            if (Array.isArray(container)) {
                for (const it of container) {
                    if (it && typeof it === "object") {
                        put(it.from ?? it.old ?? it.src, it.to ?? it.new ?? it.dst);
                    }
                }
            } else if (container && typeof container === "object") {
                for (const [k, v] of Object.entries(container)) put(k, v);
            }
            return m;
        }

        // json自体が { old: new } 形式の可能性
        for (const [k, v] of Object.entries(json)) put(k, v);
        return m;
    }

    return m;
}

function esc(s: string) {
    return s.replace(/'/g, "''");
}

function parseTarget(t: string) {
    // schema.table.column or table.column
    const parts = t.split(".");
    if (parts.length === 2) return { schema: "public", table: parts[0], col: parts[1] };
    if (parts.length === 3) return { schema: parts[0], table: parts[1], col: parts[2] };
    throw new Error(`Invalid target: ${t} (use schema.table.column or table.column)`);
}

const args = parseArgs(process.argv.slice(2));
const mapPath = args["map"];
const outPath = args["out"] ?? "public/rewrite_cards.sql";
const targetsArg = args["targets"];

if (!mapPath || !targetsArg) {
    console.error("Usage: npx tsx scripts/make-rewrite-sql.ts --map=public/db_urls.map.json --out=public/rewrite_cards.sql --targets=public.curated_cards.image_url,public.drops.cover_image_url");
    process.exit(1);
}

const absMap = path.resolve(mapPath);
const raw = fs.readFileSync(absMap, "utf8");
const json = JSON.parse(raw);
const mappings = extractMappings(json);

const entries = Object.entries(mappings)
    .filter(([k, v]) => k !== v)
    .sort(([a], [b]) => a.localeCompare(b));

if (entries.length === 0) {
    console.error("No mappings found in map file.");
    process.exit(1);
}

const targets = targetsArg.split(",").map(s => s.trim()).filter(Boolean);

let sql = "";
sql += `-- generated by scripts/make-rewrite-sql.ts\n`;
sql += `-- map: ${mapPath}\n`;
sql += `-- mappings: ${entries.length}\n\n`;
sql += `begin;\n`;
sql += `create temp table tmp_url_map(old_url text primary key, new_url text not null);\n\n`;

sql += `insert into tmp_url_map(old_url, new_url) values\n`;
sql += entries
    .map(([oldUrl, newUrl]) => `  ('${esc(oldUrl)}','${esc(newUrl)}')`)
    .join(",\n");
sql += `;\n\n`;

for (const t of targets) {
    const { schema, table, col } = parseTarget(t);
    sql += `-- TARGET: ${schema}.${table}.${col}\n`;
    // 1) 完全一致（安全）
    sql += `update ${schema}.${table} as x\n`;
    sql += `set ${col} = m.new_url\n`;
    sql += `from tmp_url_map m\n`;
    sql += `where x.${col} = m.old_url;\n\n`;

    // 2) 部分一致（フルURL等）: “1件だけマッチする場合のみ” 更新（安全寄り）
    sql += `update ${schema}.${table} as x\n`;
    sql += `set ${col} = replace(x.${col}, m.old_url, m.new_url)\n`;
    sql += `from tmp_url_map m\n`;
    sql += `where x.${col} is not null\n`;
    sql += `  and x.${col} like '%' || m.old_url || '%'\n`;
    sql += `  and not exists (\n`;
    sql += `    select 1 from tmp_url_map m2\n`;
    sql += `    where x.${col} like '%' || m2.old_url || '%'\n`;
    sql += `      and m2.old_url <> m.old_url\n`;
    sql += `  );\n\n`;

    // 検証
    sql += `select '${schema}.${table}.${col}' as target,\n`;
    sql += `  (select count(*) from ${schema}.${table} x join tmp_url_map m on x.${col} = m.old_url) as remaining_exact,\n`;
    sql += `  (select count(*) from ${schema}.${table} x where exists (select 1 from tmp_url_map m where x.${col} like '%'||m.old_url||'%')) as remaining_contains;\n\n`;
}

sql += `commit;\n`;

fs.writeFileSync(path.resolve(outPath), sql, "utf8");
console.log(`✅ wrote ${outPath} (targets: ${targets.length}, mappings: ${entries.length})`);
